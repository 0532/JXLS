<document>
    <properties>
      <author email="leonid.vysochyn@gmail.com">Leonid Vysochyn</author>
      <title>Customizing jXLS output</title>
    </properties>
	<body>
        <section name="Overview" id="overview">
            <p>In this section you will see how you can customize result workbook during XLS transformation.
            For example you may want to change style of some cells dynamically depending on exported data.
            Or you may want to change values of some bean properties for example to scale them or do something else.</p>
            <p>Many of this can be done using Excel conditional formatting or macros. jXLS provides alternative way
            to do this with custom cell and row processors.</p>
            <!--<warning>Custom Cell Processor section is DEPRECATED this time. With introducing full JEXL expressions-->
            <!--support some of the CellProcessor implementations will no longer work correctly. If you need to apply-->
            <!--custom formatting based on some bean properies values you may use jx:forEach/jx:if tags.-->
            <!--Next jXLS releases probably will change current Cell Processors support to be more efficient and useful. </warning>-->
        </section>
        <!--<section id="customCellProcessor">-->
			<!--<title>Cell Processor - Section is DEPRECATED</title>-->
			<!--<p>Sometimes it is required to set custom cell style depending on processed property value. For example-->
            <!--you may want to set red color or change font to be italic for the property of some bean if it is greater than some other property.-->
            <!--To dynamically modify cell style you can implement-->
                <!--<a href="site:project/cellprocessor">CellProcessor</a> interface.-->
            <!--It contains the only one method-->
                <!--<code>void processCell(Cell cell, Map namedCells)</code>.-->
            <!--XLSTransformer invokes this method for every registered CellProcessor and passes to it two parameters:-->
            <!--</p>-->
			<!--<ul>-->
				<!--<li>-->
					<!--<code>Cell cell</code> - contains all information about the current processed cell-->
                <!--</li>-->
				<!--<li>-->
					<!--<code>Map namedCells</code> - contains all named cells that were found while processing previous cells-->
                <!--</li>-->
			<!--</ul>-->
			<!--<p>With <a href="site:project/cell">Cell</a> object you have access to related <a href="http://jakarta.apache.org/poi/">POI</a>-->
                <!--objects to modify cell style if required. </p>-->
            <!--<p> Using <code>Cell</code> object you can get list of expressions contained in the cell.</p>-->
            <!--<p>Having <code>Expression</code> object you can get a list of all properties in this expression.</p>-->
            <!--<p>Bean properties are represented by <code>Property</code> class.</p>-->
			<!--<p>-->
				<!--<code>RedCellProcessor</code> is a sample implementation of-->
                <!--<code>CellProcessor</code> from-->
                <!--<a href="samples/dynamicstylesample#cellprocessorsample">Colouring sample</a>-->
			<!--</p>-->
            <!--<source>-->
<!--public class RedCellProcessor implements CellProcessor {-->
<!---->
    <!--static HSSFCellStyle hssfCellStyle;-->
    <!--public static final String RED_CELL = "red";-->
    <!--String beanName;-->
<!---->
    <!--public RedCellProcessor(String collectionName) {-->
        <!--this.beanName = collectionName.replace('.', '_');-->
    <!--}-->
<!---->
    <!--public void processCell(final Cell cell, final Map namedCells) {-->
        <!--if( cell.getExpressions().size()>0 ){-->
            <!--Expression expression = (Expression) cell.getExpressions().get(0);-->
            <!--Property property = (Property)expression.getProperties().get(0);-->
            <!--if (property != null &amp;&amp; property.getBeanName() != null &amp;&amp;-->
                <!--property.getBeanName().indexOf(beanName) >= 0 &amp;&amp;-->
                <!--property.getBean() instanceof Employee) {-->
                <!--Employee employee = (Employee) property.getBean();-->
                <!--if (employee.getPayment().doubleValue() >= 2000) {-->
                    <!--if (namedCells.containsKey(RED_CELL + "_" + property.getPropertyNameAfterLastDot())) {-->
                        <!--Cell redCell = (Cell) namedCells.get(RED_CELL + "_" +-->
                <!--property.getPropertyNameAfterLastDot());-->
                        <!--HSSFCellStyle redStyle = redCell.getHssfCell().getCellStyle();-->
                        <!--cell.getHssfCell().setCellStyle(redStyle);-->
                    <!--}-->
                <!--}-->
            <!--}-->
        <!--}-->
    <!--}-->
<!--}-->
            <!--</source>-->
            <!--<p>First look at <code>RedCellProcessor</code> constructor. It takes <code>beanName</code> parameter and initializes private <code>beanName</code> property with the following code</p>-->
            <!--<source>-->
            		  <!--this.beanName = beanName.replace('.', '_');-->
            <!--</source>-->
            <!--<p>It is done in this way because when <code>XLSTransformer</code> processes collection it adds additional object for every collection item with the name that is equals to the name of collection with <strong>.</strong> symbols replaced with <strong>_</strong>.</p>-->
            <!--<p>Next take a look at the section of checking is it the correct cell to change style </p>-->
            <!--<source>-->
                <!--if( cell.getExpressions().size()>0 ){-->
                    <!--Expression expression = (Expression) cell.getExpressions().get(0);-->
                    <!--Property property = (Property)expression.getProperties().get(0);-->
                    <!--if (property != null &amp;&amp; property.getBeanName() != null &amp;&amp;-->
                        <!--property.getBeanName().indexOf(beanName) >= 0 &amp;&amp;-->
                        <!--property.getBean() instanceof Employee) {-->
                        <!--Employee employee = (Employee) property.getBean();-->
                            <!--...-->
            <!--</source>-->
            <!--<p>You see that in the above code we get the first expression of the cell and then the first property in that expression.-->
                <!--Then we ensure that <code>beanName</code> property of the first <code>Property</code> contains previously initialized <code>beanName</code>.-->
                <!--If it does we also check that processed bean is an instance of <code>Employee</code> object.</p>-->
            <!--<p>If check is successful we cast current processed bean to <code>Employee</code> and check required condition</p>-->
            <!--<source>-->
                          	  <!--if (employee.getPayment().doubleValue() >= 2000) { ... }-->
            <!--</source>-->
            <!--<p>If the cell is a cell to change style we modify cell style in some tricky but easy to implement way. Let's take a look at the code </p>-->
            <!--<source>-->
                <!--if (namedCells.containsKey(RED_CELL + "_" + property.getPropertyNameAfterLastDot())) {-->
                    <!--Cell redCell = (Cell) namedCells.get(RED_CELL + "_" +-->
            <!--property.getPropertyNameAfterLastDot());-->
                    <!--HSSFCellStyle redStyle = redCell.getHssfCell().getCellStyle();-->
                    <!--cell.getHssfCell().setCellStyle(redStyle);-->
                <!--}-->
            <!--</source>-->
            <!--<p>First we check if there is a named cell in our XLS template with the name <code>RED_CELL + "_" + property.getPropertyNameAfterLastDot()</code>.-->
                <!--This check means that for example for property <code>payment</code> we are checking do we have a named cell with the name <code>red_payment</code>.-->
                <!--If such named cell exists we than get the style from that cell and assign it to the current processed cell which style should be modified:</p>-->
		<!--<source>-->
            <!--Cell redCell = (Cell) namedCells.get(RED_CELL + "_" +-->
    <!--property.getPropertyNameAfterLastDot());-->
            <!--HSSFCellStyle redStyle = redCell.getHssfCell().getCellStyle();-->
            <!--cell.getHssfCell().setCellStyle(redStyle);-->
		<!--</source>-->
		<!--<p>Obviously you have to put named cells with corresponding styles into XLS template (probably as some hidden cells).-->
            <!--This trick reduces direct manual cell style manipulation using <a href="http://jakarta.apache.org/poi/">POI API</a>.-->
            <!--But if you are good with  <a href="http://jakarta.apache.org/poi/">POI</a> you may implement style changing without <code>named cell trick</code>.-->
            <!--If you look at the XLS template for <a href="samples/dynamicstylesample.html">Dynamic Style samples</a>-->
            <!--you'll see that there is a hidden first row in the template with named cells.</p>-->
			<!--<table>-->
				<!--<tr>-->
					<!--<th/>-->
					<!--<th>A</th>-->
					<!--<th>B</th>-->
					<!--<th>C</th>-->
					<!--<th>D</th>-->
					<!--<th>E</th>-->
					<!--<th>F</th>-->
				<!--</tr>-->
				<!--<tr>-->
					<!--<td>-->
						<!--<strong>1</strong>-->
					<!--</td>-->
					<!--<td>-->
						<!--$[0]red_name-->
					<!--</td>-->
					<!--<td>-->
						<!--$[0]red_age-->
					<!--</td>-->
					<!--<td>-->
						<!--$[0]red_birthDate-->
					<!--</td>-->
					<!--<td>-->
						<!--$[0]red_payment-->
					<!--</td>-->
					<!--<td>-->
						<!--$[0]red_bonus-->
					<!--</td>-->
					<!--<td>-->
						<!--$[0]red_emplTotal-->
					<!--</td>-->
				<!--</tr>-->
			<!--</table>-->
			<!--<p>As currently there is no technique to assign a name to ordinary cell we used fake formula cells here - <strong>$[0]</strong>. You can see that using such approach it is possible to have different styles for every collection properties. </p>-->
			<!--<p>After you have implemented <code>CellProcessor</code> interface you have to register your Cell Processor with-->
                <!--<code>XLSTransformer</code>. To do this you have to invoke-->
                <!--<code>registerCellProcessor(CellProcessor processor)</code> method as in the following code-->
            <!--</p>-->
			<!--<source>-->
            		 <!--...-->
		        <!--Map beans = new HashMap();-->
		        <!--beans.put("department", department);-->
		        <!--XLSTransformer transformer = new XLSTransformer();-->
		        <!--transformer.registerCellProcessor(new RedCellProcessor("department.staff"));-->
		        <!--transformer.groupCollection("department.staff");-->
		        <!--transformer.transformXLS(templateFileName, beans, destFileName);-->
            <!--</source>-->

            <!--<section id="cellProcessorWithoutNamedCells">-->
                <!--<title>CellProcessor implementation without named cell usage - SECTION IS DEPRECATED</title>-->
                <!--<p>Below there is RedCellProcessor2 class source code. It's another implementation of <a href="site:project/cellprocessor">CellProcessor</a> interface.-->
                   <!--It does the same as RedCellProcessor class from above section but does not use-->
                    <!--named cells to set required cell style. </p>-->
                <!--<source>-->
<!--public class RedCellProcessor2  implements CellProcessor {-->
<!---->
    <!--static HSSFCellStyle hssfCellStyle;-->
    <!--String beanName;-->
<!---->
    <!--Map rowStyles = new HashMap();-->
<!---->
    <!--public RedCellProcessor2(String collectionName) {-->
        <!--this.beanName = collectionName.replace('.', '_');-->
    <!--}-->
<!---->
    <!--public void processCell(final Cell cell, final Map namedCells) {-->
        <!--if( cell.getExpressions().size()>0 ){-->
            <!--Expression expression = (Expression) cell.getExpressions().get(0);-->
            <!--Property property = (Property)expression.getProperties().get(0);-->
            <!--if (property != null &amp;&amp; property.getBeanName() != null &amp;&amp;-->
                    <!--property.getBeanName().indexOf(beanName) >= 0 &amp;&amp; property.getBean() instanceof Employee) {-->
                <!--Employee employee = (Employee) property.getBean();-->
                <!--if (employee.getPayment().doubleValue() >= 2000) {-->
                        <!--HSSFCell hssfCell = cell.getHssfCell();-->
                        <!--HSSFCellStyle newStyle = duplicateStyle( cell, property.getPropertyNameAfterLastDot() );-->
                        <!--newStyle.setFillForegroundColor( HSSFColor.RED.index );-->
                        <!--newStyle.setFillPattern( HSSFCellStyle.SOLID_FOREGROUND );-->
                        <!--hssfCell.setCellStyle( newStyle );-->
                <!--}-->
            <!--}-->
        <!--}-->
    <!--}-->
<!---->
    <!--HSSFCellStyle duplicateStyle( Cell cell, String key ){-->
        <!--if( rowStyles.containsKey( key ) ){-->
            <!--return (HSSFCellStyle) rowStyles.get( key );-->
        <!--}else{-->
            <!--HSSFCellStyle newStyle =  Util.duplicateStyle( cell.getRow().getHssfWorkbook(), cell.getHssfCell().getCellStyle() );-->
            <!--rowStyles.put( key, newStyle );-->
            <!--return newStyle;-->
        <!--}-->
    <!--}-->
<!---->
<!--}-->
                <!--</source>-->
                <!--<p>Main difference from previous implementation is-->
                    <!--<code>HSSFCellStyle duplicateStyle( Cell cell, String key )</code> method.-->
                    <!--This method takes <code>Cell</code> object and a <code>key</code> as parameters-->
                    <!--and returns POI <code>HSSFCellStyle</code> object which is a copy of the style of passed cell.</p>-->
                <!--<p><code>key</code> parameter is used to store all new created styles in a <code>rowStyles</code> Map so that-->
                    <!--we will not have to create the style for some property again if it was already created before.-->
                    <!--In <code>processCell</code> method we pass the last part of property name using-->
                    <!--<code>property.getPropertyNameAfterLastDot()</code> method and then change style HSSFCellStyle object-->
                    <!--we got.-->
                <!--</p>-->
                <!--<source>-->
                    <!--HSSFCellStyle newStyle = duplicateStyle( cell, property.getPropertyNameAfterLastDot() );-->
                    <!--newStyle.setFillForegroundColor( HSSFColor.RED.index );-->
                    <!--newStyle.setFillPattern( HSSFCellStyle.SOLID_FOREGROUND );-->
                    <!--hssfCell.setCellStyle( newStyle );-->
                <!--</source>-->
                <!--<p>Also note using of <code>static HSSFCellStyle duplicateStyle(HSSFWorkbook workbook, HSSFCellStyle style)</code>-->
                    <!--method of <code>Util</code> class to duplicate <code>HSSFCellStyle</code>.-->
                <!--</p>-->
            <!--</section>-->
        <!--</section>-->


        <section id="customRowProcessor" name="Row Processor">
			<p>You may implement <code>RowProcessor</code> interface if you need to set style for some row
                dynamically. The interface contains single method
                <code>void processRow(Row row, Map namedCells)</code>.
            XLSTransformer invokes this method for every registered CellProcessor and passes to it two parameters:
            </p>
			<ul>
				<li>
					<code>Row row</code> - contains all information about the current processed row
                </li>
				<li>
					<code>Map namedCells</code> - contains all named cells that were found during processing of previous cells
                </li>
			</ul>
			<p>With <code>Row</code> object you have access to related <a href="http://jakarta.apache.org/poi/">POI</a>
                objects to modify cell style if required. </p>
			<p> Let's take a look at <code>StyleRowProcessor</code> class from <a href="../samples/dynamicstylesample.html">Row Style sample</a>.
                This class allows to highlight some rows containing employee information for all employees with payment greater than 2000.
            </p>
            <source>
public class StyleRowProcessor implements RowProcessor {
    String collectionName;
    String styleCellLabel = "customRow";

    public StyleRowProcessor(String collectionName) {
        this.collectionName = collectionName;
    }

    public void processRow(Row row, Map namedCells) {
        // check if processed row has a parent row
        if( row.getParentRow()!=null ){
            // Processed row has parent row. It means we are processing some collection item
            RowCollection rowCollection = row.getParentRow().getRowCollectionByCollectionName( collectionName );
            if( rowCollection.getIterateObject() instanceof Employee){
                Employee employee = (Employee) rowCollection.getIterateObject();
                if( employee.getPayment().doubleValue() >= 2000 ){
                    if( namedCells.containsKey( styleCellLabel ) ){
                        Cell customCell = (Cell) namedCells.get( styleCellLabel );
                        for (int i = 0; i &lt; row.getCells().size(); i++) {
                            Cell cell = (Cell) row.getCells().get(i);
                            HSSFCell hssfCell = cell.getHssfCell();
                            if( hssfCell!=null ){
                                copyStyle( row.getHssfWorkbook(), customCell.getHssfCell(), hssfCell );
                            }
                        }
                    }
                }
            }
        }
    }
}
            </source>
            <p>You can see that in <code>processRow()</code> method we check does current row have parent row </p>
            <source>
// check if processed row has a parent row
if( row.getParentRow()!=null ){
....
            </source>
            <p>The point is that for every row that is being processed as collection item <code>XLSTransformer</code>
            sets <code>parentRow</code> property with information about base row containing current collection details.</p>
            <p>Then we get <code>RowCollection</code> object related to our collection in question using
                <code>getRowCollectionByCollectionName( collectionName )</code> method of <code>Row</code> class</p>
            <source>
// Processed row has parent row. It means we are processing some collection item
RowCollection rowCollection = row.getParentRow().getRowCollectionByCollectionName( collectionName );
            </source>
            <p>After that we check that current iterated object is of required type and cast current collection item
                to <code>Employee</code> class. And then we check its payment property</p>
            <source>
if( rowCollection.getIterateObject() instanceof Employee){
    Employee employee = (Employee) rowCollection.getIterateObject();
    if( employee.getPayment().doubleValue() >= 2000 ){ ... }
            </source>
            <p>Then we trying to find named cell with name <code>styleCellLabel</code> that is equal to <code>&quot;customRow&quot;</code></p>
            <source>
if( namedCells.containsKey( styleCellLabel ) ){
    Cell customCell = (Cell) namedCells.get( styleCellLabel );
            </source>
            <p>Then we walk through all <code>Cell</code> objects for current row and copy
            cell style from named cell to current cell</p>
            <source>
for (int i = 0; i &lt; row.getCells().size(); i++) {
    Cell cell = (Cell) row.getCells().get(i);
    HSSFCell hssfCell = cell.getHssfCell();
    if( hssfCell!=null ){
        copyStyle( row.getHssfWorkbook(), customCell.getHssfCell(), hssfCell );
    }
}
            </source>
            <p>Method <code>copyStyle(..)</code> is rather simple and just copies cell style from one cell to another.
            See <a href="../samples/dynamicstylesample.html">Row Style sample</a> for the actual code.</p>
    </section>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7339856-1");
pageTracker._trackPageview();
} catch(err) {}</script>
    </body>
</document>
